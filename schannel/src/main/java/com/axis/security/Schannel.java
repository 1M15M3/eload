/**
 * 
 */
package com.axis.security;

import java.math.BigInteger;
import java.security.cert.CertificateEncodingException;
import java.security.cert.X509Certificate;
import java.util.HashMap;
import java.util.Map.Entry;

import com.axis.common.BerTLV;
import com.axis.common.Log;
import com.axis.common.Secureutil;
import com.axis.common.ftBaseFunc;
import com.axis.common.chipher.DES;
import com.axis.common.chipher.MAC;
import com.axis.common.log.LogWrapper;
import com.axis.common.pki.CertificateHelper;
import com.axis.security.implement.Handshake;
import com.axis.transaction.Load;

/**
 * @author axis
 *
 */
public class Schannel {

	private static final LogWrapper log = Log.get();

	public static final int server = 0;
	public static final String SERVER_ASCII = "534552564552";
	public static final String CLIENT_ASCII = "434C49454E54";
	public static final String KEY_ASCII = "4B4559";
	
	public Load load = null;

	/**
	 * 终端算法标识符
	 */
	private String A1;
	/**
	 * 处理中心算法标识符
	 */
	private String A2;
	/**
	 * 客户端产生的随机数
	 */
	private String r1;
	/**
	 * 处理中心产生的随机数
	 */
	private String r2;
	/**
	 * 终端产生的共享主密钥
	 */
	private String M1;
	/**
	 * M1的密文
	 */
	private String E1;
	/**
	 * 终端签名
	 */
	private String S1;
	/**
	 * 会话加密密钥
	 */
	public String SKey;
	/**
	 * 会话MAC密钥
	 */
	public String MKey;
	
	private BigInteger seq = null;

	private Handshake helper;

	public X509Certificate serverCertificate = null;
	public X509Certificate clientCertificate = null;
	public X509Certificate caCertificate = null;
	public String serverCerts = null;

	public Schannel() {
		helper = new Handshake();
	}

	/**
	 * 
	 * @param terminalNo
	 *            终端序列号
	 * @return String 读取终端序列号指令
	 */
	public String readTerminalNO(String terminalNo) {
		return helper.readTerminalNo();
	}

	/**
	 * return random generated by server generator, </br>
	 * if server side support cipherSuite of client side. </br>
	 * else return null. </br>
	 * 
	 * @param cipherSuite
	 * @return
	 */
	private String ter = null;
	public String generateRandom(String terminalInfo) {
		TerminalInfo terminal = analyzeTerminalInfo(terminalInfo);
		if (terminal == null)
			return null;
		ter = terminal.terminalData;
		log.debug("终端 {} 请求握手", terminal.terminalData);
		if (terminal.reversal.equals(TerminalInfo.IS_REVERSAL)) {
			log.debug("终端 {} 需要冲正", terminal.terminalData);
		}
		return helper.readTerminalRandom();
	}

	/**
	 * 分析终端信息
	 * @param terminalInfo 终端信息
	 * @return TermialInfo 终端信息对象
	 */
	private TerminalInfo analyzeTerminalInfo(String terminalInfo) {
		TerminalInfo terminal = new TerminalInfo();
		
		HashMap<String, String> map = BerTLV.split(terminalInfo);
		if (map.isEmpty())
			return null;
		for (Entry<String, String> entry : map.entrySet()) {
			String tag = entry.getKey();
			String value = entry.getValue();
			switch (tag) {
			case TerminalInfo.TERMINAL_CERT_VALID_DATE:
				terminal.terminalCertsValidDate = value;
				break;
			case TerminalInfo.PLATFORM:
				terminal.platform = value;
				break;
			case TerminalInfo.CA_SERIES_NO:
				terminal.CASeriesNo = value;
				break;
			case TerminalInfo.PIN_NO:
				terminal.pinNo = value;
				break;
			case TerminalInfo.TERMINAL_ISSUER:
				terminal.terminalIssuer = value;
				break;
			case TerminalInfo.TERMINAL_TYPE:
				terminal.terminalType = value;
				break;
			case TerminalInfo.REVERSAL_FLAG:
				terminal.reversal = value;
				break;
			case TerminalInfo.ICC_NO:
				terminal.iccNo = value;
				break;
			case TerminalInfo.PUBLIC_KEY_VER:
				terminal.publicKeyVer = value;
				break;
			case TerminalInfo.TERMINAL_FIRMWARE_VER:
				terminal.terminalFirmwareVer = value;
				break;
			case TerminalInfo.TERMINAL_DATA:
				terminal.terminalData = value;
				break;
			case TerminalInfo.AID:
				terminal.icaid = value;
				break;
			default:
				break;
			}
		}
		return terminal;
	}

	/**
	 * 验证终端算法标识
	 * @param cipherSuite 终端算法标识符
	 * @return true 通过，false 不通过
	 */
	public boolean verifyTermianlCipher(String cipherSuite) {
		if (cipherSuite != null) {
			A1 = cipherSuite.substring(0, 2);
			r1 = cipherSuite.substring(2);
			if (helper.verifyChipher(A1)) {
				String cipoherSuit[] = helper.getTerminalCiperSuite();
				if (cipoherSuit != null) {
					StringBuilder temp = new StringBuilder();
					for (String string : cipoherSuit) {
						if (string == null)
							break;
						temp.append(string + " ");
					}
					log.debug("终端{}算法标识 {}，终端加密算法 {}，随机数 {}",ter, A1, temp.toString(), r1);
				}
				return true;
			}
		}
		log.error("服务器无法支持终端加密算法，终端算法标识 {} ", A1);
		return false;
	}

	/**
	 * verify terminal cipher suit if ture send server</br>
	 * certificate else return null.
	 * @param cipherSuite 终端算法标识
	 * @return String 下载服务器证书指令
	 */
	public String sendServerCertificate(String cipherSuite) {
		// 验证终端算法标识
		if (!verifyTermianlCipher(cipherSuite))
			return null;
		// 取服务器算法标识
		A2 = helper.getServerCipher();
		// 服务器随机数
		r2 = helper.generateRandom(64);
		// 服务器证书
		String certs = helper.getServerCertificateMainBody(server);
//		System.out.println("certs: "+ certs);
		serverCerts = certs;
		String serverpkg = null;

		for (int i = 0; i < Config.SERVER_CERT_PKG_NUM; i++) {

			String data = certs.substring(Config.SERVER_CERT_PKG_SIZE[i], Config.SERVER_CERT_PKG_SIZE[i + 1]);
			// OU偏移
			if (i == Config.OU_PKG_INDEX)
				data = Config.OU_OFFSET + data;
			// 公钥偏移
			else if (i == Config.PUBLIC_KEY_PKG_INDEX)
				data = Config.PUBLIC_KEY_OFFSET + data;
			// 无偏移
			else
				data = Config.NONE_OFFSET + data;

			// 起始包
			if (i == 0)
				data = Config.START_PKG_FLAG + data;
			// 终止包
			else if (i == Config.SERVER_CERT_PKG_NUM - 1)
				data = Config.END_PKG_FLAG + data;
			// 公钥包
			else if (i == Config.PUBLIC_KEY_PKG_INDEX || i == Config.PUBLIC_KEY_PKG_INDEX + 1)
				data = Config.PUBLIC_KEY_PKG_FLAG + data;
			// OU包
			else if (i == Config.OU_PKG_INDEX)
				data = Config.OU_PKG_FLAG + data;
			// 普通包
			else
				data = Config.COMMON_PKG_FLAG + data;
			
			if (i == 0)
				serverpkg = helper.sendServerCertificate(data);
			else
				serverpkg += ":"+helper.sendServerCertificate(data);
		}
		return serverpkg;
	}

	/**
	 * send server certificate signature.
	 * @return String 验证服务器证书指令
	 */
	public String verifyServerCertificate() {
		String sign = helper.getServerCertificateSignature(server);
		String signpkg = "";
		//FIXME: 终端的签名值需要Tag 和 length “0382010100”
		sign = "0382010100" + sign;

		for (int i = 0; i < Config.SERVER_SIGN_PKG_NUM; i++) {
			String data = sign.substring(Config.SERVER_SIGN_PKG_SIZE[i], Config.SERVER_SIGN_PKG_SIZE[i + 1]);
			// start pkg
			if (i == 0)
				data = Config.START_PKG_FLAG + Config.NONE_OFFSET + data;
			// end pkg
			else if (i == Config.SERVER_SIGN_PKG_NUM - 1)
				data = Config.END_PKG_FLAG + Config.NONE_OFFSET + data;
			else
				data = Config.COMMON_PKG_FLAG + Config.NONE_OFFSET + data;
			if (i == 0)
				signpkg += helper.verifyServerCertificate(data);
			else
				signpkg += ":"+helper.verifyServerCertificate(data);
		}
		return signpkg;
	}

	/**
	 * 读取终端证书
	 * @return 读取终端证书指令集
	 */
	public String readTerminalCertificate() {
		return helper.readTerminalCertificate() +":" +helper.readTerminalCertificate("");
	}

	/**
	 * read terminal master key
	 * @param terminalCert
	 * @return read terminal master key cmd.
	 */
	public String readTerminalMasterKey(X509Certificate terminalCert) {
		// 验证客户端证书合法性
		if (helper.verifyCertificateLegal(terminalCert)) {
			clientCertificate = terminalCert;
			return helper.readTerminalMasterKey();
		}
		return null;
	}
	/**
	 * read terminal signature;
	 * @param eMasterkey 暗文主密钥
	 * @return terminal signature cmd.
	 */
	public String getTerminalSignature(byte[] eMasterkey) {

		if (eMasterkey != null) {
			try {
				E1 = new ftBaseFunc().ftBytesToHexString(eMasterkey);
				byte b[];
				// 解开经过公钥加密的终端主密钥
				b = CertificateHelper.decryptByPrivateKey(eMasterkey, Config.KEY_STORE_PATH, Config.ALIAS,
						Config.KEY_STORE_PWD, Config.KEY_STORE_PWD);
				M1 = new ftBaseFunc().ftBytesToHexString(b);
				String signatureValue = A1 + r1 + A2 + r2;
				return helper.readTerminalSignature(signatureValue);
			} catch (Exception e) {
				log.error("解密终端主密钥错误\n", e);
				return null;
			}
		}
		return null;
	}

	String R1 = null, R2 = null, H2 = null, H3 = null, T1 = null, H4 = null, D1 = null;

	/**
	 * 发送服务器完成消息指令
	 * @param terminalSign 客户端签名
	 * @return 服务器完成消息指令
	 */
	public String sendServerFinishMessage(byte[] terminalSign) {
		if (terminalSign != null) {
			try {
				// 验证客户端签名
				String signSource = A1 + r1 + A2 + r2;
				if (helper.verifyTerminalSignature(new ftBaseFunc().ftHexStringToBytes(signSource), terminalSign, clientCertificate)) {
					S1 = new ftBaseFunc().ftBytesToHexString(terminalSign);
					String F1 = generateHandShakeFinishMessage(SERVER_ASCII);
					return helper.sendServerFinishMessage(F1);
				}
			} catch (Exception e) {
				log.error("验证终端签名错误\n", e);
				return null;
			}
		}
		return null;
	}

	/**
	 * 发送终端完成消息指令
	 * @return 读取终端证书指令
	 */
	public String sendReadTerminalFinishMessage() {
		return helper.readTerminalFinishMessage();
	}

	/**
	 * 握手完成消息
	 * @param terminalFinishMessage 终端握手完成消息
	 * @return 握手完成指令
	 */
	public String handShakeFinish(String terminalFinishMessage) {
		// 验证终端握手完成消息
		if (terminalFinishMessage != null) {
			String F2 = generateHandShakeFinishMessage(CLIENT_ASCII).toUpperCase();
			log.debug("终端发送F2 {}, 服务器生成F2' {}", terminalFinishMessage, F2 );
			if (F2.equals(terminalFinishMessage)) {
				generateSessionKey();
				return helper.generateSessionKey();
			}
		}
		return null;
	}
	/**
	 * 安全通道建立后，解密传输的数据
	 * @param data 需要解密的数据
	 * @return 明文数据
	 */
	public String DecryptApplicationData(String data)
	{
		log.debug("开始解密");
		log.debug("密钥SKey {}",SKey);
		log.debug("密钥MKey {}",MKey);
		log.debug("暗文响应数据 {}", data);
		int length = data.length();
		int macOffset = length-16;
		String EData = data.substring(0, macOffset);
		log.debug("暗文数据 {}", EData);
		
		String mac = data.substring(macOffset);
		String seqi = seq.toString(16);
		log.debug("当前序号 {}",seqi);
		String mac2 = MAC.macForDes_3Des(MKey, "0000000000000000", seqi+EData, MAC.IS_LONG);
		if (mac2.equals(mac)){
			if (seq != null)
				seq = seq.add(new BigInteger("1"));
			log.debug("累加后的序号 {}",seq.toString(16));
			log.debug("MAC值 {}", mac);
			String d = DES.dec3DES(SKey, EData);
			log.debug("明文响应 {}", d);
			return d;
		}
		return null;
	}
	/**
	 * 安全通道建立后，加密要传输的数据
	 * @param data 要加密的数据
	 * @return 暗文数据
	 */
	public String EncryptApplicationData(String data)
	{
		log.debug("开始加密");
		log.debug("密钥SKey {}",SKey);
		log.debug("密钥MKey {}",MKey);
		log.debug("明文指令 {}", data);
		String EData = DES.enc3DES(SKey, data, true);
		log.debug("暗文指令 {}", EData);
		
		String seqi = seq.toString(16);
		log.debug("当前序号 {}",seqi);
		String mac = MAC.macForDes_3Des(MKey, "0000000000000000", seqi+EData, MAC.IS_LONG);
		log.debug("MAC值 {}",mac);
		if (seq != null)
			seq = seq.add(new BigInteger("1"));
		log.debug("累加后的序号 {}",seq.toString(16));
		return EData+mac;
	}

	private void generateSessionKey() {
		ftBaseFunc bf = new ftBaseFunc();
		String text = KEY_ASCII + r1 + r2;
		byte[] bsessionKey = Secureutil.hmacSha1(bf.ftHexStringToBytes(M1), bf.ftHexStringToBytes(text));

		String sessionKey = bf.ftBytesToHexString(bsessionKey);
		if (sessionKey != null) {
			SKey = sessionKey.substring(0, 32);
			MKey = sessionKey.substring(8, 40);
		}
		// 起始序列号
		String seq1 = r1.substring(0, 16);
		String seq2 = r2.substring(0, 16);
		seq = new BigInteger(seq1+seq2, 16);
		
		log.debug("通讯密钥SKey:{}, MAC密钥MKey:{}", SKey, MKey);
	}

	/**
	 * 生成握手完成消息
	 * @param ascii
	 * @return 握手完成消息
	 */
	private String generateHandShakeFinishMessage(String ascii) {
		if (ascii != null) {
			ftBaseFunc bf = new ftBaseFunc();
			try {

				if (A1 != null && r1 != null)
					R1 = A1 + r1;
				if (A2 != null && r2 != null)
					R2 = A2 + r2;
				if (serverCerts != null)
					H2 = Secureutil.encrypt(bf.ftHexStringToBytes(serverCerts), Secureutil.SHA1);
				if (clientCertificate != null)
					H3 = Secureutil.encrypt(clientCertificate.getTBSCertificate(), Secureutil.SHA1);
				if (S1 != null && E1 != null)
					T1 = R1 + R2 + H2 + H3 + S1 + E1;
				if (T1 != null)
					H4 = Secureutil.encrypt(bf.ftHexStringToBytes(T1), Secureutil.SHA1);
				if (H4 != null)
					D1 = ascii + H4;

				byte[] b = Secureutil.hmacSha1(bf.ftHexStringToBytes(M1), bf.ftHexStringToBytes(D1));
				
				if(ascii.equals(CLIENT_ASCII))
					log.debug("生成 CLIENT握手完成消息\nR1={},R2={},H2={},H3={},H4={},D1={}",R1,R2,H2,H3,H4,D1);
				else
					log.debug("生成 SERVER握手完成消息\nR1={},R2={},H2={},H3={},H4={},D1={}",R1,R2,H2,H3,H4,D1);
				
				return bf.ftBytesToHexString(b);

			} catch (CertificateEncodingException e) {
				log.error("生成握手完成消息错误\n", e);
				return null;
			}
		}

		return null;
	}
	/**
	 * 安全通道建立以后，发送安全通道命令
	 * @param data 要发送的数据
	 * @param isSerial 是否级联
	 * @return 安全通道应用数据传输指令
	 */
	public String schannelCmd(String data, boolean isSerial) {
		if(isSerial)
			return helper.seriesEncryptData()+ String.format("%02x", data.length() / 2) + data;
		else
			return helper.EncrptData()+ String.format("%02x", data.length() / 2) + data;
	}

}
